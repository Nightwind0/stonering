%parser_class_name "SteelParser"
%parser_base_assigned_type "AstBase*"
%parser_class_methods_and_members{
    void setBuffer(const char *pBuffer, const std::string &script_name);
    Token::Type Scan ();
    SteelScanner *m_scanner;
    const char *m_pBuffer;
}
%parser_header_file_top { 
	#ifndef STEEL_PARSER_H
	#define STEEL_PARSER_H

	#include <cassert> 
	#include "Ast.h"
	class SteelScanner;
}
%parser_header_file_bottom {
	#endif // STEEL_PARSER_H
}

%parser_implementation_file_top {
	#include "SteelScanner.h"
	#include "Ast.h"
}

%parser_implementation_file_bottom {

void SteelParser::setBuffer(const char * pBuffer, const std::string &name)
{	
	assert( NULL != m_scanner );
	m_scanner->setBuffer(pBuffer,name);
}


SteelParser::Token::Type SteelParser::Scan ()
{
	assert(m_scanner != NULL);
	return m_scanner->Scan(&m_lookahead_token);
}
}

%parser_constructor_actions{
    m_scanner = new SteelScanner();
}

%parser_destructor_actions{
    delete m_scanner;
}


%token ';' '(' ')' '=' '{' '}' '[' ']' ','
%token '-' '+' '*' '/' '^' '%'
%token D
%token GT LT EQ NE GTE LTE
%token AND OR NOT
%token WHILE
%token BREAK
%token CONTINUE
%token RETURN
%token IF
%token ELSE
%token FUNCTION
%token FUNC_IDENTIFIER
%token VAR_IDENTIFIER
%token ARRAY_IDENTIFIER
%token LOOP
%token TIMES
%token USING
%token VAR
%token INT
%token FLOAT
%token STRING


%prec NON_ELSE
%prec ELSE
%prec ASSIGNMENT
%prec OR
%prec AND
%prec EQ_NE
%prec COMPARATOR
%prec ADD_SUB
%prec MULT_DIV_MOD
%prec POW
%prec UNARY
%prec PAREN


%start root
%%

root %type "AstScript*"
:
	statement_list:list 
			{
				AstScript * pScript =  new AstScript(list->GetLine(),list->GetScript());
			        pScript->SetList(list);
				return pScript;
			} 
|
	func_definition_list:list
			{
				AstScript * pScript = new AstScript(list->GetLine(),list->GetScript());
				pScript->SetFunctionList( list );
				return pScript;
			}
;

func_definition_list %type "AstFunctionDefinitionList*"
:
	func_definition:def     {
					AstFunctionDefinitionList * pList = new AstFunctionDefinitionList(def->GetLine(),def->GetScript());
					pList->add(def);
					return pList;
				}
|
	func_definition_list:list func_definition:def
				{
					list->add(def);
					return list;
				}	
;

func_definition %type "AstFunctionDefinition*"
:
	FUNCTION FUNC_IDENTIFIER:id '(' param_definition:params ')' '{' statement_list:stmts '}'
				{
					return new AstFunctionDefinition(id->GetLine(),
									id->GetScript(),
									static_cast<AstFuncIdentifier*>(id),
									params,
									stmts);
				}
|
	FUNCTION FUNC_IDENTIFIER:id '(' ')' '{' statement_list:stmts '}'
				{
					return new AstFunctionDefinition(id->GetLine(),
									id->GetScript(),
									static_cast<AstFuncIdentifier*>(id),
									NULL,
									stmts);
				}
;



param_definition %type "AstParamDefinitionList*"
:
	VAR_IDENTIFIER:id 
			{
				AstParamDefinitionList * pList = new AstParamDefinitionList(id->GetLine(),id->GetScript());
				pList->add(static_cast<AstVarIdentifier*>(id));
				return pList;		
			}
|
	param_definition:list ',' VAR_IDENTIFIER:id
			{
				list->add(static_cast<AstVarIdentifier*>(id));
				return list;
			}
;

statement_list %type "AstStatementList*"
:
	statement:stmt 	{
				AstStatementList *pList = new AstStatementList( stmt->GetLine(),
										stmt->GetScript());
				pList->add(stmt);
				return pList;
			}
|
	statement_list:list statement:stmt
				{
					list->add( stmt ); 
					return list;
				}
;

statement %type "AstStatement*"
:
	';' { return new AstExpression(0,""); }
|
	exp:exp ';' { return new AstExpressionStatement(exp->GetLine(),exp->GetScript(), exp); }
|
	'{' statement_list:list '}' { return list; }
|
	vardecl:vardecl ';' { return vardecl; }
|
	WHILE '(' exp:exp ')' statement:stmt { return new AstWhileStatement(exp->GetLine(), exp->GetScript(),exp,stmt); }
|
	IF '(' exp:exp ')' statement:stmt ELSE statement:elses %prec ELSE { return new AstIfStatement(exp->GetLine(), exp->GetScript(),exp,stmt,elses);}
|
	IF '(' exp:exp ')' statement:stmt %prec NON_ELSE { return new AstIfStatement(exp->GetLine(),exp->GetScript(),exp,stmt); }
|
	RETURN exp:exp ';' { return new AstReturnStatement(exp->GetLine(),exp->GetScript(),exp);}
|
	RETURN:returns ';'
			{
				int line = returns->GetLine();
			    	std::string script = returns->GetScript();
				delete returns;
				return new AstReturnStatement(line,script);
			}
|
	LOOP '(' exp:exp ')' TIMES USING var_identifier:id statement:stmt
			{
				return new AstLoopStatement(exp->GetLine(),exp->GetScript(),exp,id,stmt);
			}
|
	BREAK:breaks ';' 
			{
				int line = breaks->GetLine();
				std::string script = breaks->GetScript();
				delete breaks; 
				return new AstBreakStatement(line,script); 
			}
|
	CONTINUE:continues ';' 
			{
				int line = continues->GetLine();
				std::string script = continues->GetScript();
				delete continues;
				return new AstContinueStatement(line,script); 
			}
;


exp %type "AstExpression*"
:
	call:call { return call; }
|
	INT:i { return i;}
|	
	FLOAT:f { return f; }
|
	STRING:s { return s; }
|
	var_identifier:id { return id; }
|
	exp:a '+' exp:b %prec ADD_SUB { return new AstBinOp(a->GetLine(),a->GetScript(),AstBinOp::ADD,a,b); }
|
	exp:a '-' exp:b %prec ADD_SUB { return new AstBinOp(a->GetLine(),a->GetScript(),AstBinOp::SUB,a,b); }
|
	exp:a '*' exp:b %prec MULT_DIV_MOD { return new AstBinOp(a->GetLine(),a->GetScript(),AstBinOp::MULT,a,b); }
|
	exp:a '/' exp:b %prec MULT_DIV_MOD { return new AstBinOp(a->GetLine(),a->GetScript(),AstBinOp::DIV,a,b); }
|
	exp:a '%' exp:b %prec MULT_DIV_MOD { return new AstBinOp(a->GetLine(),a->GetScript(),AstBinOp::MOD,a,b); }
|
	exp:a D exp:b %prec POW { return new AstBinOp(a->GetLine(),a->GetScript(),AstBinOp::D,a,b); }
|
	var_identifier:id '=' exp:exp %right { return new AstVarAssignmentExpression(id->GetLine(),id->GetScript(),id,exp); }
|
	exp:a '^' exp:b %right %prec POW { return new AstBinOp(a->GetLine(),a->GetScript(),AstBinOp::POW,a,b); }
|
	exp:a OR exp:b %prec OR { return new AstBinOp(a->GetLine(),a->GetScript(),AstBinOp::OR,a,b); }
|
	exp:a AND exp:b %prec AND { return new AstBinOp(a->GetLine(),a->GetScript(),AstBinOp::AND,a,b); }
|
	exp:a EQ exp:b %prec EQ_NE { return new AstBinOp(a->GetLine(),a->GetScript(),AstBinOp::EQ,a,b); }
|
	exp:a NE exp:b %prec EQ_NE { return new AstBinOp(a->GetLine(),a->GetScript(),AstBinOp::NE,a,b); }
|
	exp:a LT exp:b %prec COMPARATOR { return new AstBinOp(a->GetLine(),a->GetScript(),AstBinOp::LT,a,b); }
|
	exp:a GT exp:b %prec COMPARATOR { return new AstBinOp(a->GetLine(),a->GetScript(),AstBinOp::GT,a,b); }
|
	exp:a LTE exp:b %prec COMPARATOR { return new AstBinOp(a->GetLine(),a->GetScript(),AstBinOp::LTE,a,b); }
|
	exp:a GTE exp:b %prec COMPARATOR { return new AstBinOp(a->GetLine(),a->GetScript(),AstBinOp::GTE,a,b); }	
|
	'(' exp:exp ')' %prec PAREN { return exp; }
|
	'-' exp:exp %right %prec UNARY { return new AstUnaryOp(exp->GetLine(), exp->GetScript(), AstUnaryOp::MINUS,exp); }
|
	'+' exp:exp %right %prec UNARY { return new AstUnaryOp(exp->GetLine(), exp->GetScript(), AstUnaryOp::PLUS,exp); }
|
	NOT exp:exp %right %prec UNARY { return new AstUnaryOp(exp->GetLine(), exp->GetScript(), AstUnaryOp::NOT,exp); }
|
	array_lvalue:lvalue %prec PAREN { return lvalue; }
;

int_literal %type "AstInteger*"
:
	INT:i { return i; }
;

var_identifier %type "AstVarIdentifier*"
:
	VAR_IDENTIFIER:id { return id; }
;

func_identifier %type "AstFuncIdentifier*"
:
	FUNC_IDENTIFIER:id { return id; }
;

array_identifier %type "AstArrayIdentifier*"
:
	ARRAY_IDENTIFIER:id { return id; }
;

array_lvalue %type "AstArrayExpression*"
:
	array_identifier:id '[' exp:exp ']' { return new AstArrayExpression(id->GetLine(),id->GetScript(),id,exp); }
;

call %type "AstCallExpression*"
:
	func_identifier:id '(' ')' { return new AstCallExpression(id->GetLine(),id->GetScript(),id);}
|
	func_identifier:id '(' param_list:params ')' { return new AstCallExpression(id->GetLine(),id->GetScript(),id,params);}
;

vardecl %type "AstDeclaration*"
:
	VAR var_identifier:id { return new AstVarDeclaration(id->GetLine(),id->GetScript(),id);}
|
	VAR var_identifier:id '=' exp:exp { return new AstVarDeclaration(id->GetLine(),id->GetScript(),id,exp); }
|
	VAR array_identifier:id '[' int_literal:i ']' { return new AstArrayDeclaration(id->GetLine(),id->GetScript(),id,i); }
;

param_list %type "AstParamList*"
:
	exp:exp { AstParamList * pList = new AstParamList ( exp->GetLine(), exp->GetScript() );
		  pList->add(exp);
		  return pList;
		}
|
	param_list:list ',' exp:exp { list->add(exp); return list;}
			    
;


