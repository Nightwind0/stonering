%parser_class_name "SteelParser"
%parser_base_assigned_type "AstBase*"
%parser_class_methods_and_members{
    void setBuffer(const char *pBuffer);	
    Token::Type Scan ();
    SteelScanner *m_scanner;
    const char *m_pBuffer;	
}
%parser_header_file_top { 
	#ifndef STEEL_PARSER_H
	#define STEEL_PARSER_H

	#include <cassert> 
	class AstBase;
	class SteelScanner;
}
%parser_header_file_bottom {
	#endif // STEEL_PARSER_H
}

%parser_implementation_file_top {
	#include "SteelScanner.h"
	#include "Ast.h"
}

%parser_implementation_file_bottom {
void SteelParser::setBuffer(const char * pBuffer)
{	
	assert( NULL != m_scanner );
	m_scanner->setBuffer(pBuffer);
}


SteelParser::Token::Type SteelParser::Scan ()
{
	assert(m_scanner != NULL);
	return m_scanner->Scan(&m_lookahead_token);
	//return m_scanner->Scan(&token);
}
}

%parser_constructor_actions{
    m_scanner = new SteelScanner();
}

%parser_destructor_actions{
    delete m_scanner;
}


%token ';' '(' ')' '=' '{' '}' '[' ']' ','
%token '-' '+' '*' '/' '^' '%'
%token D
%token GT LT EQ NE GTE LTE
%token AND OR NOT
%token WHILE
%token BREAK
%token CONTINUE
%token RETURN
%token IF
%token ELSE
%token FUNCTION
%token FUNC_IDENTIFIER
%token VAR_IDENTIFIER
%token ARRAY_IDENTIFIER
%token LOOP
%token TIMES
%token USING
%token VAR
%token INT
%token FLOAT
%token STRING
%token INCREMENT
%token DECREMENT

%prec NON_ELSE
%prec ELSE
%prec ASSIGNMENT
%prec OR
%prec AND
%prec EQ_NE
%prec COMPARATOR
%prec ADD_SUB
%prec MULT_DIV_MOD
%prec POW
%prec UNARY
%prec PAREN


%start root
%%

root
:
	statement_list
|
	func_definition_list
;

func_definition_list
:
	func_definition
|
	func_definition_list func_definition
;

func_definition
:
	FUNCTION FUNC_IDENTIFIER '(' param_definition ')' statement
|
	FUNCTION FUNC_IDENTIFIER '(' ')' statement
;

param_definition
:
	VAR_IDENTIFIER
|
	param_definition ',' VAR_IDENTIFIER
;

statement_list
:
	statement
|
	statement_list statement
;

statement
:
	';'
|
	exp ';' 
|
	'{' statement_list '}'
|
	vardecl ';'
|
	WHILE '(' exp ')' statement
|
	IF '(' exp ')' statement ELSE statement %prec ELSE
|
	IF '(' exp ')' statement %prec NON_ELSE
|
	RETURN exp ';'
|
	RETURN ';'
|
	LOOP '(' exp ')' TIMES USING VAR_IDENTIFIER statement
|
	BREAK ';'
|
	CONTINUE ';'
;


exp
:
	call
|
	INT
|	
	FLOAT
|
	STRING
|
	VAR_IDENTIFIER
|
	exp '+' exp %prec ADD_SUB 
|
	exp '-' exp %prec ADD_SUB
|
	exp '*' exp %prec MULT_DIV_MOD
|
	exp '/' exp %prec MULT_DIV_MOD
|
	exp '%' exp %prec MULT_DIV_MOD
|
	exp D exp %prec POW
|
	VAR_IDENTIFIER '=' exp %right
|
	exp '^' exp %right %prec POW
|
	exp OR exp %prec OR
|
	exp AND exp %prec AND
|
	exp EQ exp %prec EQ_NE
|
	exp NE exp %prec EQ_NE
|
	exp LT exp %prec COMPARATOR
|
	exp GT exp %prec COMPARATOR
|
	exp LTE exp %prec COMPARATOR
|
	exp GTE exp %prec COMPARATOR	
|
	'(' exp ')' %prec PAREN
|
	'-' exp %right %prec UNARY
|
	'+' exp %right %prec UNARY
|
	NOT exp %right %prec UNARY
|
	INCREMENT exp %prec UNARY
|
	DECREMENT exp %prec UNARY
|
	exp INCREMENT %prec UNARY
|
	exp DECREMENT %prec UNARY
|
	ARRAY_IDENTIFIER '[' exp ']' %prec PAREN
;

call
:
	FUNC_IDENTIFIER '(' ')'
|
	FUNC_IDENTIFIER '(' param_list ')'
;

vardecl
:
	VAR VAR_IDENTIFIER
|
	VAR VAR_IDENTIFIER '=' exp
|
	VAR ARRAY_IDENTIFIER '[' INT ']'
;

param_list
:
	exp
|
	param_list ',' exp
;


